{
  "version": 3,
  "sources": ["../../../@strapi/plugin-documentation/node_modules/@strapi/admin/admin/src/utils/getPrefixedId.ts", "../../../@strapi/plugin-documentation/node_modules/@strapi/admin/admin/src/utils/normalizeAPIError.ts", "../../../@strapi/plugin-documentation/node_modules/@strapi/admin/admin/src/hooks/useAPIErrorHandler.ts", "../../../@strapi/plugin-documentation/node_modules/@strapi/admin/admin/src/components/PageHelpers.tsx"],
  "sourcesContent": ["/**\n * Prefix message with 'apiError.'\n */\nexport function getPrefixedId(message: string, callback?: (prefixedMessage: string) => string) {\n  const prefixedMessage = `apiError.${message}`;\n\n  // if a prefix function has been passed in it is used to\n  // prefix the id, e.g. to allow an error message to be\n  // set only for a localization namespace\n  if (typeof callback === 'function') {\n    return callback(prefixedMessage);\n  }\n\n  return prefixedMessage;\n}\n", "import { getPrefixedId } from './getPrefixedId';\n\nimport type { ApiError } from '../hooks/useAPIErrorHandler';\nimport type { FetchError } from '../utils/getFetchClient';\nimport type { errors } from '@strapi/utils';\n\nexport interface NormalizeErrorOptions {\n  name?: string;\n  intlMessagePrefixCallback?: (id: string) => string;\n}\n\ninterface NormalizeErrorReturn {\n  id: string;\n  defaultMessage: string;\n  name?: string;\n  values: Record<'path', string> | Record<string, never>;\n}\n\ninterface YupFormattedError {\n  path: string[];\n  message: string;\n  name: string;\n  value: string;\n}\n\nfunction normalizeError(\n  error: ApiError | YupFormattedError,\n  { name, intlMessagePrefixCallback }: NormalizeErrorOptions\n): NormalizeErrorReturn {\n  const { message } = error;\n\n  const normalizedError = {\n    id: getPrefixedId(message, intlMessagePrefixCallback),\n    defaultMessage: message,\n    name: error.name ?? name,\n    values: {},\n  };\n\n  if ('path' in error) {\n    normalizedError.values = { path: error.path.join('.') };\n  }\n\n  return normalizedError;\n}\n\nconst validateErrorIsYupValidationError = (\n  err: ApiError\n): err is errors.YupValidationError & { details: { errors: YupFormattedError[] } } =>\n  typeof err.details === 'object' && err.details !== null && 'errors' in err.details;\n\n/**\n * Normalize the format of `ResponseError`\n * in places where the hook `useAPIErrorHandler` can not called\n * (e.g. outside of a React component).\n */\nexport function normalizeAPIError(\n  apiError: FetchError,\n  intlMessagePrefixCallback?: NormalizeErrorOptions['intlMessagePrefixCallback']\n):\n  | NormalizeErrorReturn\n  | { name: string; message: string | null; errors: NormalizeErrorReturn[] }\n  | null {\n  const error = apiError.response?.data?.error;\n\n  if (error) {\n    // some errors carry multiple errors (such as ValidationError)\n    if (validateErrorIsYupValidationError(error)) {\n      return {\n        name: error.name,\n        message: error?.message || null,\n        errors: error.details.errors.map((err) =>\n          normalizeError(err, { name: error.name, intlMessagePrefixCallback })\n        ),\n      };\n    }\n    return normalizeError(error, { intlMessagePrefixCallback });\n  }\n\n  return null;\n}\n", "import * as React from 'react';\n\nimport { IntlFormatters, useIntl } from 'react-intl';\n\nimport { FetchError, ApiError } from '../utils/getFetchClient';\nimport { getPrefixedId } from '../utils/getPrefixedId';\nimport { NormalizeErrorOptions, normalizeAPIError } from '../utils/normalizeAPIError';\nimport { setIn } from '../utils/objects';\n\ninterface UnknownApiError {\n  /**\n   * The name of the ApiError, is always a static value.\n   */\n  name: 'UnknownError';\n  /**\n   * The error message.\n   */\n  message: string;\n  /**\n   * The error details.\n   */\n  details?: unknown;\n  /**\n   * The HTTP status code of the error.\n   */\n  status?: number;\n}\n\n/**\n * The last item is the fallback error SerializedError which\n * typically comes from redux-toolkit itself.\n */\ninterface SerializedError {\n  /**\n   * The name of the error.\n   */\n  name?: string;\n  /**\n   * The error message that explains what went wrong.\n   */\n  message?: string;\n  /**\n   * The stack trace of the error.\n   */\n  stack?: string;\n  /**\n   * A specific error code associated with the error.\n   */\n  code?: string;\n}\n\n/**\n * These are the types or errors we return\n * from the redux-toolkit data-fetching setup.\n */\ntype BaseQueryError = ApiError | UnknownApiError | SerializedError;\n\ninterface YupFormattedError {\n  /**\n   * An array representing the path to the field where the validation error occurred.\n   */\n  path: string[];\n  /**\n   * The error message describing the validation failure.\n   */\n  message: string;\n  /**\n   * The name of the error, typically identifies the type of validation error that occurred.\n   */\n  name: string;\n\n  value: string;\n}\n\n/**\n * @public\n * @description The purpose of this hook is to offer a unified way to handle errors thrown by API endpoints, regardless of the type of error (`ValidationError`, `ApplicationErrror` ...)\nthat has been thrown.\n * @example\n * ```tsx\n * import * as React from 'react';\n * import { useFetchClient, useAPIErrorHandler, useNotification } from '@strapi/admin/admin';\n *\n * const MyComponent = () => {\n *   const { get } = useFetchClient();\n *   const { formatAPIError } = useAPIErrorHandler(getTrad);\n *   const { toggleNotification } = useNotification();\n *\n *   const handleDeleteItem = async () => {\n *     try {\n *       return await get('/admin');\n *     } catch (error) {\n *       toggleNotification({\n *         type: 'danger',\n *         message: formatAPIError(error),\n *       });\n *     }\n *   };\n *   return <button onClick={handleDeleteItem}>Delete item</button>;\n * };\n * ```\n */\nexport function useAPIErrorHandler(\n  intlMessagePrefixCallback?: FormatAPIErrorOptions['intlMessagePrefixCallback']\n) {\n  const { formatMessage } = useIntl();\n\n  /**\n   * @description This method try to normalize the passed error\n   * and then call formatAPIError to stringify the ResponseObject\n   * into a string. If it fails it will call formatFetchError and\n   * return the error message.\n   */\n  const formatError = React.useCallback(\n    (error: FetchError) => {\n      // Try to normalize the passed error first. This will fail for e.g. network\n      // errors which are thrown by fetchClient directly.\n      try {\n        const formattedErr = formatAPIError(error, { intlMessagePrefixCallback, formatMessage });\n\n        if (!formattedErr) {\n          return formatFetchError(error, { intlMessagePrefixCallback, formatMessage });\n        }\n\n        return formattedErr;\n      } catch (_) {\n        throw new Error('formatAPIError: Unknown error:', error);\n      }\n    },\n    [formatMessage, intlMessagePrefixCallback]\n  );\n\n  return {\n    /**\n     * @alpha\n     * Convert ValidationErrors from the API into an object that can be used by forms.\n     */\n    _unstableFormatValidationErrors: React.useCallback(\n      (error: Extract<BaseQueryError, { name: 'ValidationError' }>): Record<string, string> => {\n        if (typeof error.details === 'object' && error.details !== null) {\n          if ('errors' in error.details && Array.isArray(error.details.errors)) {\n            const validationErrors = error.details.errors as YupFormattedError[];\n\n            return validationErrors.reduce((acc, err) => {\n              const { path, message } = err;\n\n              return setIn(acc, path.join('.'), message);\n            }, {});\n          } else {\n            const details = error.details as Record<string, string[]>;\n\n            return Object.keys(details).reduce((acc, key) => {\n              const messages = details[key];\n\n              return {\n                ...acc,\n                [key]: messages.join(', '),\n              };\n            }, {});\n          }\n        } else {\n          return {};\n        }\n      },\n      []\n    ),\n    /**\n     * @alpha\n     * This handles the errors given from `redux-toolkit`'s axios based baseQuery function.\n     */\n    _unstableFormatAPIError: React.useCallback(\n      (error: BaseQueryError) => {\n        const err = {\n          response: {\n            data: {\n              error,\n            },\n          },\n        } as FetchError;\n\n        /**\n         * There's a chance with SerializedErrors that the message is not set.\n         * In that case we return a generic error message.\n         */\n        if (!error.message) {\n          return 'Unknown error occured.';\n        }\n\n        return formatError(err);\n      },\n      [formatError]\n    ),\n    formatAPIError: formatError,\n  };\n}\n\nfunction formatFetchError(\n  error: FetchError,\n  { intlMessagePrefixCallback, formatMessage }: FormatAPIErrorOptions\n) {\n  const { code, message } = error;\n\n  return formatMessage(\n    {\n      id: getPrefixedId(message, intlMessagePrefixCallback),\n      defaultMessage: message,\n    },\n    {\n      code,\n    }\n  );\n}\n\ntype FormatAPIErrorOptions = Partial<Pick<NormalizeErrorOptions, 'intlMessagePrefixCallback'>> &\n  Pick<IntlFormatters, 'formatMessage'>;\n\n/**\n * @description This method stringifies the `ResponseObject` into\n * a string. If multiple errors are thrown by the API, which\n * happens e.g.in the case of a `ValidationError`, all errors\n * will bo concatenated into a single string.\n */\nfunction formatAPIError(\n  error: FetchError,\n  { formatMessage, intlMessagePrefixCallback }: FormatAPIErrorOptions\n) {\n  if (!formatMessage) {\n    throw new Error('The formatMessage callback is a mandatory argument.');\n  }\n\n  const normalizedError = normalizeAPIError(error, intlMessagePrefixCallback);\n\n  if (!normalizedError) {\n    return null;\n  }\n\n  if ('message' in normalizedError && normalizedError.message !== null) {\n    return normalizedError.message;\n  }\n\n  // stringify multiple errors\n  if ('errors' in normalizedError) {\n    return normalizedError.errors\n      .map(({ id, defaultMessage, values }) => formatMessage({ id, defaultMessage }, values))\n      .join('\\n');\n  }\n\n  return formatMessage(normalizedError);\n}\n\nexport type { ApiError };\n", "import * as React from 'react';\n\nimport {\n  Box,\n  EmptyStateLayout,\n  type EmptyStateLayoutProps,\n  Flex,\n  Loader,\n  Main,\n  MainProps,\n} from '@strapi/design-system';\nimport { WarningCircle } from '@strapi/icons';\nimport { EmptyPermissions, EmptyDocuments } from '@strapi/icons/symbols';\nimport { useIntl } from 'react-intl';\n\nimport { useAuth, Permission } from '../features/Auth';\nimport { useNotification } from '../features/Notifications';\nimport { useAPIErrorHandler } from '../hooks/useAPIErrorHandler';\nimport { useCheckPermissionsQuery } from '../services/auth';\n\n/* -------------------------------------------------------------------------------------------------\n * Main\n * -----------------------------------------------------------------------------------------------*/\ninterface PageMainProps extends MainProps {\n  children: React.ReactNode;\n}\n\nconst PageMain = ({ children, ...restProps }: PageMainProps) => {\n  return <Main {...restProps}>{children}</Main>;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Loading\n * -----------------------------------------------------------------------------------------------*/\ninterface LoadingProps {\n  /**\n   * @default 'Loading content.'\n   */\n  children?: React.ReactNode;\n}\n\n/**\n * @public\n * @description A loading component that should be rendered as the page\n * whilst you load the content for the aforementioned page.\n */\nconst Loading = ({ children = 'Loading content.' }: LoadingProps) => {\n  return (\n    <PageMain height=\"100vh\" aria-busy={true}>\n      <Flex alignItems=\"center\" height=\"100%\" justifyContent=\"center\">\n        <Loader>{children}</Loader>\n      </Flex>\n    </PageMain>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Error\n * -----------------------------------------------------------------------------------------------*/\ninterface ErrorProps extends Partial<EmptyStateLayoutProps> {}\n\n/**\n * TODO: should we start passing our errors here so they're persisted on the screen?\n * This could follow something similar to how the global app error works...?\n */\n\n/**\n * @public\n * @description An error component that should be rendered as the page\n * when an error occurs.\n */\nconst Error = (props: ErrorProps) => {\n  const { formatMessage } = useIntl();\n\n  return (\n    <PageMain height=\"100%\">\n      <Flex alignItems=\"center\" height=\"100%\" justifyContent=\"center\">\n        <EmptyStateLayout\n          icon={<WarningCircle width=\"16rem\" />}\n          content={formatMessage({\n            id: 'anErrorOccurred',\n            defaultMessage: 'Whoops! Something went wrong. Please, try again.',\n          })}\n          {...props}\n        />\n      </Flex>\n    </PageMain>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * NoPermissions\n * -----------------------------------------------------------------------------------------------*/\ninterface NoPermissionsProps extends Partial<EmptyStateLayoutProps> {}\n\n/**\n * @public\n * @description A component that should be rendered as the page\n * when the user does not have the permissions to access the content.\n * This component does not check any permissions, it's up to you to decide\n * when it should be rendered.\n */\nconst NoPermissions = (props: NoPermissionsProps) => {\n  const { formatMessage } = useIntl();\n\n  return (\n    <PageMain height=\"100%\">\n      <Flex alignItems=\"center\" height=\"100%\" justifyContent=\"center\">\n        <Box minWidth=\"50%\">\n          <EmptyStateLayout\n            icon={<EmptyPermissions width=\"16rem\" />}\n            content={formatMessage({\n              id: 'app.components.EmptyStateLayout.content-permissions',\n              defaultMessage: \"You don't have the permissions to access that content\",\n            })}\n            {...props}\n          />\n        </Box>\n      </Flex>\n    </PageMain>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * NoData\n * -----------------------------------------------------------------------------------------------*/\ninterface NoDataProps extends Partial<EmptyStateLayoutProps> {}\n\n/**\n * @public\n * @description A component that should be rendered as the page\n * when there is no data available to display.\n * This component does not check any permissions, it's up to you to decide\n * when it should be rendered.\n */\nconst NoData = (props: NoDataProps) => {\n  const { formatMessage } = useIntl();\n\n  return (\n    <PageMain height=\"100%\" background=\"neutral100\">\n      <Flex alignItems=\"center\" height=\"100%\" width=\"100%\" justifyContent=\"center\">\n        <Box minWidth=\"50%\">\n          <EmptyStateLayout\n            icon={<EmptyDocuments width=\"16rem\" />}\n            action={props.action}\n            content={formatMessage({\n              id: 'app.components.EmptyStateLayout.content-document',\n              defaultMessage: 'No content found',\n            })}\n            {...props}\n          />\n        </Box>\n      </Flex>\n    </PageMain>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Protect\n * -----------------------------------------------------------------------------------------------*/\nexport interface ProtectProps {\n  /**\n   * The children to render if the user has the required permissions.\n   * If providing a function, it will be called with an object containing\n   * the permissions the user has based on the array you passed to the component.\n   */\n  children: React.ReactNode | ((args: { permissions: Permission[] }) => React.ReactNode);\n  /**\n   * The permissions the user needs to have to access the content.\n   */\n  permissions?: Array<Omit<Partial<Permission>, 'action'> & Pick<Permission, 'action'>>;\n}\n\n/**\n * @public\n * @description A wrapper component that should be used to protect a page. It will check the permissions\n * you pass to it and render the children if the user has the required permissions. If a user does not have ALL\n * the required permissions, it will redirect the user to the home page. Whilst these checks happen it will render\n * the loading component and should the check fail it will render the error component with a notification.\n */\nconst Protect = ({ permissions = [], children }: ProtectProps) => {\n  const userPermissions = useAuth('Protect', (state) => state.permissions);\n  const { toggleNotification } = useNotification();\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\n\n  const matchingPermissions = userPermissions.filter(\n    (permission) =>\n      permissions.findIndex(\n        (perm) => perm.action === permission.action && perm.subject === permission.subject\n      ) >= 0\n  );\n\n  const shouldCheckConditions = matchingPermissions.some(\n    (perm) => Array.isArray(perm.conditions) && perm.conditions.length > 0\n  );\n\n  const { isLoading, error, data } = useCheckPermissionsQuery(\n    {\n      permissions: matchingPermissions.map((perm) => ({\n        action: perm.action,\n        subject: perm.subject,\n      })),\n    },\n    {\n      skip: !shouldCheckConditions,\n    }\n  );\n\n  React.useEffect(() => {\n    if (error) {\n      toggleNotification({\n        type: 'danger',\n        message: formatAPIError(error),\n      });\n    }\n  }, [error, formatAPIError, toggleNotification]);\n\n  if (isLoading) {\n    return <Loading />;\n  }\n\n  if (error) {\n    return <Error />;\n  }\n\n  const { data: permissionsData } = data || {};\n\n  const canAccess =\n    shouldCheckConditions && permissionsData\n      ? !permissionsData.includes(false)\n      : matchingPermissions.length > 0;\n\n  if (!canAccess) {\n    return <NoPermissions />;\n  }\n\n  return (\n    <>\n      {typeof children === 'function' ? children({ permissions: matchingPermissions }) : children}\n    </>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Title\n * -----------------------------------------------------------------------------------------------*/\nexport interface TitleProps {\n  children: string;\n}\n\n/**\n * @public\n * @description This component takes the children (must be a string) and sets\n * it as the title of the html.\n */\nconst Title = ({ children: title }: TitleProps) => {\n  React.useEffect(() => {\n    document.title = `${title} | Strapi`;\n  }, [title]);\n\n  return null;\n};\n\nconst Page = {\n  Error,\n  Loading,\n  NoPermissions,\n  Protect,\n  NoData,\n  Main: PageMain,\n  Title,\n};\n\nexport { Page };\nexport type { ErrorProps, LoadingProps, NoPermissionsProps, PageMainProps as MainProps };\n"],
  "mappings": "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",
  "names": ["getPrefixedId", "message", "callback", "prefixedMessage", "normalizeError", "error", "name", "intlMessagePrefixCallback", "message", "normalizedError", "id", "getPrefixedId", "defaultMessage", "values", "path", "join", "validateErrorIsYupValidationError", "err", "details", "normalizeAPIError", "apiError", "response", "data", "errors", "map", "useAPIErrorHandler", "intlMessagePrefixCallback", "formatMessage", "useIntl", "formatError", "useCallback", "error", "formattedErr", "formatAPIError", "formatFetchError", "_", "Error", "_unstableFormatValidationErrors", "details", "Array", "isArray", "errors", "validationErrors", "reduce", "acc", "err", "path", "message", "setIn", "join", "Object", "keys", "key", "messages", "_unstableFormatAPIError", "response", "data", "code", "id", "getPrefixedId", "defaultMessage", "normalizedError", "normalizeAPIError", "map", "values", "PageMain", "children", "restProps", "_jsx", "Main", "Loading", "height", "aria-busy", "Flex", "alignItems", "justifyContent", "Loader", "Error", "props", "formatMessage", "useIntl", "EmptyStateLayout", "icon", "WarningCircle", "width", "content", "id", "defaultMessage", "NoPermissions", "Box", "minWidth", "EmptyPermissions", "NoData", "background", "EmptyDocuments", "action", "Protect", "permissions", "userPermissions", "useAuth", "state", "toggleNotification", "useNotification", "_unstableFormatAPIError", "formatAPIError", "useAPIErrorHandler", "matchingPermissions", "filter", "permission", "findIndex", "perm", "subject", "shouldCheckConditions", "some", "Array", "isArray", "conditions", "length", "isLoading", "error", "data", "useCheckPermissionsQuery", "map", "skip", "React", "useEffect", "type", "message", "permissionsData", "canAccess", "includes", "_Fragment", "Title", "title", "document", "Page"]
}
