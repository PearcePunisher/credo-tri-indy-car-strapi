{
  "version": 3,
  "sources": ["../../../fractional-indexing/src/index.js"],
  "sourcesContent": ["// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS =\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error(\"invalid integer part of order key: \" + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= \"a\" && head <= \"z\") {\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\n  } else if (head >= \"A\" && head <= \"Z\") {\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error(\"invalid order key head: \" + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === \"A\" + digits[0].repeat(26)) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === \"Z\") {\n      return \"a\" + digits[0];\n    }\n    if (head === \"z\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > \"a\") {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === \"a\") {\n      return \"Z\" + digits.slice(-1);\n    }\n    if (head === \"A\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < \"Z\") {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return \"a\" + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === \"A\" + digits[0].repeat(26)) {\n      return ib + midpoint(\"\", fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error(\"cannot decrement any more\");\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error(\"cannot increment any more\");\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n"],
  "mappings": "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",
  "names": ["ib", "fb", "ia", "fa", "i", "c"]
}
