{
  "version": 3,
  "sources": ["../../../@strapi/admin/admin/src/utils/cookies.ts", "../../../@strapi/admin/admin/src/utils/getFetchClient.ts", "../../../@strapi/admin/admin/src/utils/baseQuery.ts", "../../../@strapi/admin/admin/src/services/api.ts"],
  "sourcesContent": ["/**\n * Retrieves the value of a specified cookie.\n *\n * @param name - The name of the cookie to retrieve.\n * @returns The decoded cookie value if found, otherwise null.\n */\nexport const getCookieValue = (name: string): string | null => {\n  let result = null;\n  const cookieArray = document.cookie.split(';');\n  cookieArray.forEach((cookie) => {\n    const [key, value] = cookie.split('=').map((item) => item.trim());\n    if (key === name) {\n      result = decodeURIComponent(value);\n    }\n  });\n  return result;\n};\n\n/**\n * Sets a cookie with the given name, value, and optional expiration time.\n *\n * @param name - The name of the cookie.\n * @param value - The value of the cookie.\n * @param days - (Optional) Number of days until the cookie expires. If omitted, the cookie is a session cookie.\n */\nexport const setCookie = (name: string, value: string, days?: number): void => {\n  let expires = '';\n  if (days) {\n    const date = new Date();\n    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n    expires = `; Expires=${date.toUTCString()}`;\n  }\n  document.cookie = `${name}=${encodeURIComponent(value)}; Path=/${expires}`;\n};\n\n/**\n * Deletes a cookie by setting its expiration date to a past date.\n *\n * @param name - The name of the cookie to delete.\n */\nexport const deleteCookie = (name: string): void => {\n  document.cookie = `${name}=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`;\n};\n", "import pipe from 'lodash/fp/pipe';\nimport qs from 'qs';\n\nimport { getCookieValue } from './cookies';\n\nimport type { errors } from '@strapi/utils';\n\nexport type ApiError =\n  | errors.ApplicationError\n  | errors.ForbiddenError\n  | errors.NotFoundError\n  | errors.NotImplementedError\n  | errors.PaginationError\n  | errors.PayloadTooLargeError\n  | errors.PolicyError\n  | errors.RateLimitError\n  | errors.UnauthorizedError\n  | errors.ValidationError\n  | errors.YupValidationError;\n\nconst STORAGE_KEYS = {\n  TOKEN: 'jwtToken',\n  USER: 'userInfo',\n};\n\ntype FetchResponse<TData = any> = {\n  data: TData;\n  status?: number;\n};\n\ntype FetchOptions = {\n  params?: any;\n  signal?: AbortSignal;\n  headers?: Record<string, string>;\n  validateStatus?: ((status: number) => boolean) | null;\n};\n\ntype FetchConfig = {\n  signal?: AbortSignal;\n};\n\ninterface ErrorResponse {\n  data: {\n    data?: any;\n    error: ApiError & { status?: number };\n  };\n}\n\nclass FetchError extends Error {\n  public name: string;\n  public message: string;\n  public response?: ErrorResponse;\n  public code?: number;\n  public status?: number;\n\n  constructor(message: string, response?: ErrorResponse) {\n    super(message);\n    this.name = 'FetchError';\n    this.message = message;\n    this.response = response;\n    this.code = response?.data?.error?.status;\n    this.status = response?.data?.error?.status;\n\n    // Ensure correct stack trace in error object\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FetchError);\n    }\n  }\n}\n\nconst isFetchError = (error: unknown): error is FetchError => {\n  return error instanceof FetchError;\n};\n\nconst getToken = (): string | null => {\n  const fromLocalStorage = localStorage.getItem(STORAGE_KEYS.TOKEN);\n  if (fromLocalStorage) {\n    return JSON.parse(fromLocalStorage);\n  }\n\n  const fromCookie = getCookieValue(STORAGE_KEYS.TOKEN);\n  return fromCookie ?? null;\n};\n\ntype FetchClient = {\n  get: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\n  put: <TData = any, TSend = any>(\n    url: string,\n    data?: TSend,\n    config?: FetchOptions\n  ) => Promise<FetchResponse<TData>>;\n  post: <TData = any, TSend = any>(\n    url: string,\n    data?: TSend,\n    config?: FetchOptions\n  ) => Promise<FetchResponse<TData>>;\n  del: <TData = any>(url: string, config?: FetchOptions) => Promise<FetchResponse<TData>>;\n};\n\n/**\n * @public\n * @param {FetchConfig} [defaultOptions={}] - Fetch Configs.\n * @returns {FetchClient} A fetch client object with methods for making HTTP requests.\n * @description This is an abstraction around the native fetch exposed by a function. It provides a simple interface to handle API calls\n * to the Strapi backend.\n * @example\n * ```tsx\n * import { getFetchClient } from '@strapi/admin/admin';\n *\n * const myFunct = () => {\n *   const { get } = getFetchClient();\n *   const requestURL = \"/some-endpoint\";\n *\n *   const { data } = await get(requestURL);\n *\n *   return data;\n * };\n * ```\n */\nconst getFetchClient = (defaultOptions: FetchConfig = {}): FetchClient => {\n  const backendURL = window.strapi.backendURL;\n  const defaultHeader = {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${getToken()}`,\n  };\n\n  const isFormDataRequest = (body: unknown) => body instanceof FormData;\n  const addPrependingSlash = (url: string) => (url.charAt(0) !== '/' ? `/${url}` : url);\n\n  // This regular expression matches a string that starts with either \"http://\" or \"https://\" or any other protocol name in lower case letters, followed by \"://\" and ends with anything else\n  const hasProtocol = (url: string) => new RegExp('^(?:[a-z+]+:)?//', 'i').test(url);\n\n  // Check if the url has a prepending slash, if not add a slash\n  const normalizeUrl = (url: string) => (hasProtocol(url) ? url : addPrependingSlash(url));\n\n  // Add a response interceptor to return the response\n  const responseInterceptor = async <TData = any>(\n    response: Response,\n    validateStatus?: FetchOptions['validateStatus']\n  ): Promise<FetchResponse<TData>> => {\n    try {\n      const result = await response.json();\n\n      /**\n       * validateStatus allows us to customize when a response should throw an error\n       * In native Fetch API, a response is considered \"not ok\"\n       * when the status code falls in the 200 to 299 (inclusive) range\n       */\n      if (!response.ok && result.error && !validateStatus?.(response.status)) {\n        throw new FetchError(result.error.message, { data: result });\n      }\n\n      if (!response.ok && !validateStatus?.(response.status)) {\n        throw new FetchError('Unknown Server Error');\n      }\n\n      return { data: result };\n    } catch (error) {\n      if (error instanceof SyntaxError && response.ok) {\n        // Making sure that a SyntaxError doesn't throw if it's successful\n        return { data: [], status: response.status } as FetchResponse<any>;\n      } else {\n        throw error;\n      }\n    }\n  };\n\n  const paramsSerializer =\n    <Param = unknown>(params?: Param) =>\n    (url: string) => {\n      if (params) {\n        if (typeof params === 'string') {\n          return `${url}?${params}`;\n        }\n\n        /**\n         * TODO V6: Encoding should be enabled in this step\n         * So the rest of the app doesn't have to worry about it,\n         * It's considered a breaking change because it impacts any API request, including the user's custom code\n         */\n        const serializedParams = qs.stringify(params, { encode: false });\n        return `${url}?${serializedParams}`;\n      }\n      return url;\n    };\n\n  const addBaseUrl = (url: Parameters<typeof fetch>[0]) => {\n    return `${backendURL}${url}`;\n  };\n\n  /**\n   * We use the factory method because the options\n   * are unique to the individual request\n   */\n  const makeCreateRequestUrl = (options?: FetchOptions) =>\n    pipe(normalizeUrl, addBaseUrl, paramsSerializer(options?.params));\n\n  const fetchClient: FetchClient = {\n    get: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n      /**\n       * this applies all our transformations to the URL\n       * - normalizing (making sure it has the correct slash)\n       * - appending our BaseURL which comes from the window.strapi object\n       * - serializing our params with QS\n       */\n      const createRequestUrl = makeCreateRequestUrl(options);\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'GET',\n        headers,\n      });\n\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    post: async <TData, TSend = any>(\n      url: string,\n      data?: TSend,\n      options?: FetchOptions\n    ): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n\n      /**\n       * we have to remove the Content-Type value if it was a formData request\n       * the browser will automatically set the header value\n       */\n      if (isFormDataRequest(data)) {\n        headers.delete('Content-Type');\n      }\n\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'POST',\n        headers,\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\n      });\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    put: async <TData, TSend = any>(\n      url: string,\n      data?: TSend,\n      options?: FetchOptions\n    ): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n\n      /**\n       * we have to remove the Content-Type value if it was a formData request\n       * the browser will automatically set the header value\n       */\n      if (isFormDataRequest(data)) {\n        headers.delete('Content-Type');\n      }\n\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'PUT',\n        headers,\n        body: isFormDataRequest(data) ? (data as FormData) : JSON.stringify(data),\n      });\n\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n    del: async <TData>(url: string, options?: FetchOptions): Promise<FetchResponse<TData>> => {\n      const headers = new Headers({\n        ...defaultHeader,\n        ...options?.headers,\n      });\n\n      const createRequestUrl = makeCreateRequestUrl(options);\n      const response = await fetch(createRequestUrl(url), {\n        signal: options?.signal ?? defaultOptions.signal,\n        method: 'DELETE',\n        headers,\n      });\n      return responseInterceptor<TData>(response, options?.validateStatus);\n    },\n  };\n\n  return fetchClient;\n};\n\nexport { getFetchClient, isFetchError, FetchError };\nexport type { FetchOptions, FetchResponse, FetchConfig, FetchClient, ErrorResponse };\n", "import { SerializedError } from '@reduxjs/toolkit';\nimport { BaseQueryFn } from '@reduxjs/toolkit/query';\n\nimport { getFetchClient, type FetchOptions, ApiError, isFetchError } from '../utils/getFetchClient';\n\ninterface QueryArguments {\n  url: string;\n  method?: 'GET' | 'POST' | 'DELETE' | 'PUT';\n  data?: unknown;\n  config?: FetchOptions;\n}\n\ninterface UnknownApiError {\n  name: 'UnknownError';\n  message: string;\n  details?: unknown;\n  status?: number;\n}\n\ntype BaseQueryError = ApiError | UnknownApiError;\n\nconst simpleQuery: BaseQueryFn<string | QueryArguments, unknown, BaseQueryError> = async (\n  query,\n  { signal }\n) => {\n  try {\n    const { get, post, del, put } = getFetchClient();\n\n    if (typeof query === 'string') {\n      const result = await get(query, { signal });\n      return { data: result.data };\n    } else {\n      const { url, method = 'GET', data, config } = query;\n\n      if (method === 'POST') {\n        const result = await post(url, data, {\n          ...config,\n          signal,\n        });\n        return { data: result.data };\n      }\n\n      if (method === 'DELETE') {\n        const result = await del(url, {\n          ...config,\n          signal,\n        });\n        return { data: result.data };\n      }\n\n      if (method === 'PUT') {\n        const result = await put(url, data, {\n          ...config,\n          signal,\n        });\n        return { data: result.data };\n      }\n\n      /**\n       * Default is GET.\n       */\n      const result = await get(url, {\n        ...config,\n        signal,\n      });\n      return { data: result.data };\n    }\n  } catch (err) {\n    // Handle error of type FetchError\n\n    if (isFetchError(err)) {\n      if (\n        typeof err.response?.data === 'object' &&\n        err.response?.data !== null &&\n        'error' in err.response?.data\n      ) {\n        /**\n         * This will most likely be ApiError\n         */\n        return { data: undefined, error: err.response?.data.error as any };\n      } else {\n        return {\n          data: undefined,\n          error: {\n            name: 'UnknownError',\n            message: err.message,\n            details: err.response,\n            status: err.status,\n          } as UnknownApiError,\n        };\n      }\n    }\n\n    const error = err as Error;\n    return {\n      data: undefined,\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n      } satisfies SerializedError,\n    };\n  }\n};\n\nconst fetchBaseQuery = () => simpleQuery;\n\nconst isBaseQueryError = (error: BaseQueryError | SerializedError): error is BaseQueryError => {\n  return error.name !== undefined;\n};\n\nexport { fetchBaseQuery, isBaseQueryError };\nexport type { BaseQueryError, UnknownApiError, QueryArguments };\n", "import { createApi } from '@reduxjs/toolkit/query/react';\n\nimport { fetchBaseQuery } from '../utils/baseQuery';\n\n/**\n * @public\n * @description This is the redux toolkit api for the admin panel, users\n * should use a combination of `enhanceEndpoints` to add their TagTypes\n * to utilise in their `injectEndpoints` construction for automatic cache\n * re-validation. We specifically do not store any tagTypes by default leaving\n * the API surface as small as possible. None of the data-fetching looks for the\n * StrapiApp are stored here either.\n */\nconst adminApi = createApi({\n  reducerPath: 'adminApi',\n  baseQuery: fetchBaseQuery(),\n  tagTypes: [],\n  endpoints: () => ({}),\n});\n\nexport { adminApi };\n"],
  "mappings": "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",
  "names": ["getCookieValue", "name", "result", "cookieArray", "document", "cookie", "split", "forEach", "key", "value", "map", "item", "trim", "decodeURIComponent", "setCookie", "days", "expires", "encodeURIComponent", "deleteCookie", "STORAGE_KEYS", "TOKEN", "USER", "FetchError", "Error", "constructor", "message", "response", "name", "code", "data", "error", "status", "captureStackTrace", "isFetchError", "getToken", "fromLocalStorage", "localStorage", "getItem", "JSON", "parse", "fromCookie", "getCookieValue", "getFetchClient", "defaultOptions", "backendURL", "window", "strapi", "defaultHeader", "Accept", "Authorization", "isFormDataRequest", "body", "FormData", "addPrependingSlash", "url", "charAt", "hasProtocol", "RegExp", "test", "normalizeUrl", "responseInterceptor", "validateStatus", "result", "json", "ok", "SyntaxError", "paramsSerializer", "params", "serializedParams", "qs", "stringify", "encode", "addBaseUrl", "makeCreateRequestUrl", "options", "pipe", "fetchClient", "get", "headers", "Headers", "createRequestUrl", "fetch", "signal", "method", "post", "delete", "put", "del", "simpleQuery", "query", "signal", "get", "post", "del", "put", "getFetchClient", "result", "data", "url", "method", "config", "err", "isFetchError", "response", "undefined", "error", "name", "message", "details", "status", "stack", "fetchBaseQuery", "isBaseQueryError", "adminApi", "createApi", "reducerPath", "baseQuery", "fetchBaseQuery", "tagTypes", "endpoints"]
}
